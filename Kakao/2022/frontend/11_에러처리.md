# Sentry를 이용한 에러 추적기, React의 선언적 에러 처리
- [Youtube](https://www.youtube.com/watch?v=012IPbMX_y4)
- [발표자료](https://speakerdeck.com/kakao/sentryreul-iyonghan-ereo-cujeoggi-reactyi-seoneonjeog-ereo-ceori)

## 목차
- Sentry
   - Sentry를 이용한 데이터 수집
   - Severity 기준 설정과 모니터링
   - 에러 데이터 분석
   - 개선 후, 이런 점이 좋아졌어요
- React
   - 기존의 에러 처리
   - Error Boundaries
   - 라이브러리와 Error Boundaries
   - 선언적 에러 처리
   - 선언적 에러 처리의 장

## Frontend에서의 에러
- 데이터 영역에서의 에러
- 화면 영역에서의 에러
- 외부요인에 의한 에러
- 런타임 에러
   - 예측이 어려운 에러

## 에러 추적을 개선해보자
- 에러 데이터 쌓기
- Severity 기준 설정 및 모니터링
- 에러 데이터 분석
- 분석 결과에 따른 개선

### 에러 데이터 쌓기

#### Sentry
- 실시간 로그 취합 및 분석 도구이자 모니터링 플랫폼
- 로그에 대한 다양한 정보를 제공하고 시각화 도구를 통해 발생한 이벤트를 쉽게 분석할 수 있도록 도와줍니다
- 다양한 플랫폼을 지원합니다

##### 에러 데이터 전송
- captureEception(): 에러 객체와 문자열 전송
- captureMessage(): 문자열 전송
- 에러 데이터는 쌓았는데 검색도 어렵고, 구분하기도 어렵고...
- Scopes
   - configureScope로는 공통 정보를
   - withScope로는 각 에러 상황 시 추가 정보를
- Add Context
   - 이벤트에 임의의 데이터를 연결할
   - 검색은 할 수 없고 해당 이벤트가 발생한 이벤트 로그에서 확인
- Issue Grouping
   - 모든 이벤트는 finterprint를 가지고 있습니다
   - fingerprint가 동일한 이벤트는 하나의 이슈로 그룹화되면 재설정 할 수 있습니다
- Transaction Name
- Breadcrumbs
- Level
   - 이벤트마다 level을 설정하여 중요도를 식별 가능
   - fatal, error, warning, log, info, debug, critical로 severity 설정 가능
- Customized Tags
   - tag는 기와 값이 쌍으로 이루어진 문자열
   - tag는 인덱싱이 되는 요소이기 때문에 이슈 검색 및 트래킹을 신속하게 진행할 수 있습니다

### Severity 기준 설정 및 모니터링
- 알람 조건 설정하기
   - when
      - 처음 보는 이슈가 생길 경우
      - 해결된 이슈가 다시 발생할 경우
      - 무시하고 있던 이슈가 해제될 경우
   - if
      - Level
      - Attribute
      - Tag
      - N번 중복 발생
   - then
      - Slack
      - kakaowork
      - jira

### 에러 데이터 분석
- 에러 데이터 수집 전 세웠던 가설
   - QA 과정을 거치기 때문에 화면 영역에서 발생하는 에러는 많지 않을 것이다
   - 데이터 영역에서 발생하는 API에 대한 에러가 대부분일 것이다
   - 특정 기기나 브라우저에서 발생하는 에러가 있을 것이다

### 분석 결과에 따른 개선
- 유의미한 데이터를 수집하자
   - chunk load 에러나 network 에러는 수집 제외 (timeout 에러는 수집)
   - 분석하고자 하는 API의 http status를 구분하여 수집 (4xx 에러는 수집 제외)
   - 에러 데이터 뿐만 아니라 디버깅과 분석에 필요한 추가적인 정보 수집
   - tag, level 등의 기능을 이용해 디버깅에 필요한 정보성 데이터 수집

- 서버와의 로그 분석 정합성 높이기
- 서버와 약속된 custom header를 추가하여 API를 요청
- 에러 상황 시 서버 로그와 프론트엔드에 남은 데이터를 서로 대조하여 분석의 정합성을 높일 수 있음

### 에러 추적 개선 후, 이런 점이 좋아졌어요
- 브라우저 버전 문제나 빌드 설정과 같은 문제로 발생한 예상하지 못했던 에러들을 발견하여 사용자 경험을 개선
   - 폴리필 추가하여 해결
- 장애 탐지 시간, 원인 파악, 해결까지의 시간 감소
- CS 인입 시 사용자 환경에서 재현하지 않아도 에러 원인을 파악하고 정확하게 안내가 가능해짐
- 개발자 경험이 좋아짐

## 에러 처리를 개선해보자
- 사용자 경험을 어렵게 만드는 기존의 에러 처리
   - 하나의 API에서 에러가 발생해도 에러 페이지로 이동

### 에러/예외 케이스 화면들
- 일반적인 에러: API 에러 또는 화면에서 런타임 에러 발생 시
- 네트워크 에러: 네트워크나 청크로드 에러 발생 시
- 강제 업데이트
- 서비스 점검 페이지

### axios intercepter
- 기존의 에러 처리는 axios interceptor의 reject callback으로 처리
```TypeScript
axios.interceptors.response.use(_, onResponseRejected);

function onResponseRejected(error: Error) {
  return new Promise((_, reject) => {
    // ... 중략 ...

    // 네트워크 에러 체크
    if (checkIsAxiosNetworkError(error)) {
      setTimeout(() => { handleNetworkError(error, reject); }, 200);
      return
    }

    // 타임아웃 에러 체크
    if (checkIsAxiosTimeoutError(error)) {
      return handleTimeoutError(error, reject);
    }

    const errorCode = error.response?.data?.errorCode;
    const status = error.response?.status;

    // 서버와 정의한 에러 코드로 인한 코드 분기
    if (errorCode) {
      switch(errorCode) {
        case '계정이상':
          return handleKickOutError(error);

        // ... 중략 ...
      }
    }

  });
}
```

### axios interceptor, 이런 점이 불편했어요
- 에러 화면을 보여주려면 라우트 이동으로 처리해야만 하는 불편함이 있었습니다
- 전역 에러를 처리하는 것은 수월하나 화면의 일부만 에러 상태로 대응하는 것은 어렵습니다

### React Error Boundaries
- React 16에서 도입된 에러 경계(error boundaries)를 활용하여 하위 컴포넌트 트리의 자바스크립트 에러를 포착하고, Fallback UI를 보여줄 수 있습니다
- 에러 바운더리를 통해 선언적 에러 처리가 가능합니다

### 명령형 프로그래밍 & 선언형 프로그래밍
- 명령형 프로그래밍: How
- 선언형 프로그래밍: What

### 명령형 에러 처리 & 선언형 에러 처리

#### 명령형 에러 처리
```jsx
const ComponentWithPossibleError = () => {
  const { error: err1 } = useSomeQuery();
  const { error: err2 } = useAnotherQuery();

  if (err1 || err2) {
    return <ErrorFallback />;
  }

  return <NormalComponent />;
};
```

#### 선언형 에러 처리
```jsx
const ComponentWithPossibleError = () => {
  return (
    <ApiErrorBoundary>
      <NormalComponent />
    </ApiErrorBoundary>
  );
};
```

### ErrorBoundaries의 구조
```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  // 다음 렌더링에서 fallback UI가 보이도록 상태 업데이트
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  // 에러 리포팅 서비스에 에러 기록
  componentDidCatch(error, errorInfo) {
    logException(error, errorInfo);
  }

  render() {
    // 커스텀한 fallback UI 렌더링
    if (this.state.hasError) {
      return <h1>Something wenth wrong.</h1>;
    }

    return this.props.children;
  }
}
```

### react-error-boundary
```jsx
import { ReactErrorBoundary } from 'react-error-boundary';

// 서비스 성격이나 에러 상황에 적절한 fallback component 구현 가능
const FallbackComponent = () => {
  return (
    <div>에러페이지</div>
  );
}

export const App = () => {
  return (
    <ReactErrorBoundary fallback={<FallbackComponent />}>
      <Routes>
        {/* 중략 */}
      </Routes>
    </ReactErrorBoundary>
  );
}
```

### react-query와 Error Boundaries
- React의 Error Boundaries는 본래 이벤트 핸들러의 에러를 포착하지 않습니다
- react-query에서는 useErrorBondary 옵션을 제공하여, API에서 에러가 발생하면 이를 Error BOundaries가 캐치할 수 있습니다

### 선언적 에러 처리를 적용해보자
- axios interceptor 코드 줄이기
- Error Boundaries의 관심사 분리
- Error Boundaries 및 Fallback Component 작성

#### axios interceptor 코드 줄이기
```TypeScript
// AS-IS Interceptor
// 네트워크 에러 체크
if (checkIsAxiosNetworkError(error)) {
  setTimeout(() => { handleNetworkError(error, reject); }, 200);
  return
}

// 타임아웃 에러 체크
if (checkIsAxiosTimeoutError(error)) {
  return handleTimeoutError(error, reject);
}

const errorCode = error.response?.data?.errorCode;
const status = error.response?.status;

// 서버와 정의한 에러 코드로 인한 코드 분기
if (errorCode) {
  switch(errorCode) {
    case '계정이상':
      return handleKickOutError(error);

    // ... 중략 ...
  }
}

// TO-BE Interceptor - Error Boundary로 위임
if (isAxiosError(error) && isNetworkError(error)) {
  setTimeout(() => { reject(error); }, 200);
} else {
  reject(error);
}
```

#### Error Boundaries의 관심사 분리
- Error BOundaries를 관심사별로 분리하기 위해 중첩으로 구성
```jsx
import { Outlet } from 'react-router-dom';

import { ApiErrorBoundary, RootErrorBoundary } from '~/shared/components';

export const AppLayout = () => {
  return (
    {/* 그 외 Frontend Error */}
    <RootErrorBoundary>
     {/* API에서 발생하는 Error */}
      <ApiErrorBoundary>
        <Outlet />
      </ApiErrorBoundary>
    </RootErrorBoundary>
  );
};
```

#### Error Boundaries 및 Fallback Component 작성

##### Fallback Component 작성
```jsx
function FallbackComponent({ error, resetErrorBoundary }) {
  useEffect(() => {
    captureApiError(error);
  }, []);

  // 상위 Error Boundaries인 Global Error Boundaries로 에러 위임
  if (!isAxiosError(error)) {
    throw error;
  }
  /* 중략 */

  // 500 Error & 기타 일반 API 에러
  return (
    <CommonErrorHandler resetErrorBoundary={resetErrorBoundary} />
  );
}

// API 에러를 처리하는 Error Boundaries (Root Level)
const ApiErrorBoundary = ({ children }) => {
  // react-query에서 query를 reset하는 custom hook
  const { reset } = useQueryErrorResetBoundary();
  const { key } = useLocation();

  return (
    <ReactErrorBoundary
      fallback={FallbackComponent}
      onReset={reset}
      resetKeys={[key]}
    >
      {children}
    </ReactErrorBoundary>
  );
};
```

##### Local(Block) Error Boundaries
```jsx
const FallbackComponent = ({ error }) => {
  // 공통 에러 처리가 필요한 에러들은 상위로 위임
  if (isApiRequiredError(error)) {
    throw error;
  } else {
    return <RetryErrorFallback {...props} />;
  }
}

const LocalApiErrorBoundary = ({ children }) => {
  return (
    <ErrorBoundary fallback={FallbackComponent}>
      {children}
    </ErrorBoundary>
  );
}

const ProductList = () => {
  return (
    <>
      <Container>
        <Banners />
        <Title />
        <FundCompareButton />
        {/* Local Error Boundaries를 적용하여 일부만 에러 표시 */}
        <LocalApiErrorBoundary height={300}>
          <AllProductList />
        </LocalApiErrorBoundary>
      </Container>

      <Footer />
    </>
  );
};
```

### 에러 처리 개선 후, 이런 점이 좋아졌어요
- 비즈니스 로직에 집중한 에러 처리가 가능합니다
- UI 일부에서 발생하는 에러를 전역으로 전파시키지 않고 처리할 수 있습니다

### 선언적 에러 처리를 고민해야 하는 부분도 존재합니다
- 전역에서 처리되어야 하는 에러를 구분해야 합니다
```jsx
export function FallbackComponent({ error, resetErrorBoundary }) {
  // PayAxiosError가 아니라면 상위 Error Boundaries로 위임
  if (!isAxiosError(error)) {
    throw error;
  }

  // 중략...
}

export function FallbackComponent({ error, resetErrorBoundary }) {
  if (!isAxiosError(error)) {
    return <ExceptionSection onClickButton={resetErrorBoundary} />;
  }

  // ApiErrorBoundary에서 처리해야 하는 에러라면 위임
  if (isRootApiError(error)) {
    throw error;
  }

  // 중략...
}
```
