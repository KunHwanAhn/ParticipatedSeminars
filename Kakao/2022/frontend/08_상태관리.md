# 복잡한 상태관리도구 Svelte스럽게 만들기 Svelte를+RX를 이용한 Write less code 상태관리 라이브러리 개발이야기
- [Youtube](https://www.youtube.com/watch?v=-1O6WXRHA6k)
- [발표자료](https://speakerdeck.com/kakao/bogjabhan-sangtaegwanridogu-svelteseureobge-mandeulgi)

## 목차
- 상태관리 라이브러리를 만들게 된 배경
- Svelte에 Rx 더하기
- 프론트엔드 아키텍쳐 다시 써보기
- 실전과 부딫히며 라이브러리 확장 / 개선하기
- 카카오워크웹파트 사용 후기
- 배운점, 그리고 향후 로드맵

## 상태관리 라이브러리를 만들게 된 배경
- React - Redux
- Vue - Vuex
- Angluar - NgRx
- Svelte - ???
   - Svelte는 상태관리가 이미 프레임워크에 포함되어 있음

### 우리가 상태 관리를 사용하는 이유
- 전역 상태 / 공유 상태 제공
- Props Drill Problem 이슈 해결
- 뷰 로직과 비즈니스 로직의 분리
- 상태가 언제 어떻게 왜 변화하였는지 추적하기
- 상태 변화를 예측 가능하게 프로그래밍하기
- 디버깅을 용이하게 하기

### 복잡한 상태 관리에 대한 고민과 문제들
- 전여전히 컴포넌트 간 복잡하게 얽히는 데이터 흐름과 구조
- 데이터 변화 추적과 디버깅이 점점 더 힘들어진다
- 이걸 전역 스토어로만 해결하는게 맞을까?
- 전역 스토어는 전역 변수랑 뭐가 다르지?
- 컴포넌트가 비즈니스 로직에 의존성이 있어도 되는 걸까?
- 뷰 로직과 비즈니스 로직의 분리의 경계란?
- 좋은 구조란 무엇인가?
- 이런 고민을 한다는 것 부터가 일단 지금이 좋은게 아니라는 거겠지?

### 더 나은 Svelte용 상태 관리 라이브러리르 만들자
- Atomic 상태관리
   - 쉽고 단순하지만 복잡도가 올라갈수록 관리가 어려움
- 서버 기반 상태관리
   - 대부분 좋으나 특이 케이스 대응이 어려움

> 내가 하는 개발은 엔터프라이즈 FE, 앞으로 점점 더 복잡해질 수 밖에 없다
> 쉽고 편리함보다 복잡하더라도 추적과 디버깅에 용이한 더 체계적인 상태관리 라이브러리가 필요하다

> Svelte의 철학 = Write less Code

## Svelte에 Rx 더하기
- Rx란? 반응형 프로그래밍을 할 수 있도록 해주는 API
- 반응형 프로그래밍? 스프레드 시트의 연산식과 비슷하다
   - 값이 변화하면 연관된 모든 값들이 자동으로 변화한다

### JavaScript는 반응형이 아니다
```JavaScript
let A = 1;
let B = A + 1;
let C = A + B;

console.log(A, B, C); // 1, 2, 3

A = 2;
console.log(A, B, C); // 2, 2, 3, A의 값을 바꿔도 B, C는 그대로이다

A = 3;
console.log(A, B, C); // 3, 2, 3
```

### Rx에서는 이런식으로 반응형을 만들어줍니다
```JavaScript
// Rx
const A = new BehaviorSubject(0);
const B = A.pipe(map((A) => A + 1));
const C = combieLatest(A, B).pipe(map(([A, B]) => A + B))

A.next(1);
A.next(2);
A.next(3);
```

### Svelte도 반응형을 지원하는데 왜 RX인가요?
```Svelte
// store.svelte
const A = writable(0);
$: B = $A + 1;
$: C = $A + $B;
```
```JavaScript
// store.js
const A = writable(0);
const B = derived(A, (A) => A + 1);
const C = derived([A, B], ([A, B]) => A + B);
```

### Rx는 시간도 선언적으로 다룰 수 있게 해준다
- 트리플 클릭 구현하기
```JavaScript
// 트리플 클릭을 구현해볼까?
fromEvent(window, 'click') // 클릭 이벤트를
  .bufferTime(250) // 0.25초마다 모아서
  .map((clicks) => clicks.length) // 개수를 세어
  .filter((numClicks) => numClicks >= 3) // 3회 이상이면
```
- 7초 동안 응답이 없으면 에러처리, 에러가 발생하면 3초 후 다시 시도, 3번 실패하면 에러
```JavaScript
const request = (params) => http.POST('/foo/bar', params)
  .timeout(7000) // 7초동안 응답이 없으면 에러처리
  .retryWhen(error => error.delay(3000) // 에러가 발생하면 3초 후 다시 시도
    .take(3) // 3번 까지
    .concat(Observable.throw(error)) // 이후 에러 발생
  )
```

## 프론트엔드 아키텍쳐 다시 써보기
- Flux로부터 시작된 상태관리 아키텍처
- 그리고 Redux 아키텍처
- 영감을 받은 Rx 아키텍처
   - Cycle.js - MVI 아키텍처
   - NgRx - Rx + Redux

### MVI 아키텍처
- Model - View - Intent
- Unidirectional cycle of data
- Non-blocking
- Immutable state
- => Functional Paradigm

#### User(View(Model(Intent(User(screen)))))
- screen -> event -> action -> state -> screen
- type User = (screen) => event
- type Intent = (event) =>  action
- type Model = (action) => state
- type View = (state) => screen

#### MIV 아키테겇 관점에서 Svelte + Redux 바라보기
- Component
- Action
- Reducer
- Store

### Adorable Store
- **a**ction()
- **d**ispatch()
- **o**n()
- **r**educer()

### Action과 Reducer는 왜 쓰는 건가요?
- 컴포넌트와 상태 관리 코드를 완전히 분리할 수 있어 화면 변화에 유연해집니다
   - 프로그래밍을 사용자의 행동을 중심으로 생각할 수 있도록 해줍니다
- 상태가 변경되는 코드를 하나의 모듈에 고립시킬 수 있습니다
- 언제, 왜 데이터가 어떻게 변했는지 추적이 가능합니다
- 서비스가 복잡해지고 관리해야 할 상태가 늘어나도 화면 변화 대응에 유연하고 상태변화 추적에 용이하며 디버깅하기 쉬운 개발을 할 수 있다

## 실전과 부딫히며 라이브러리 확장 / 개선하기
- 웹 프론트엔드 프로그래밍을 어렵게 만드는 요소
   - 비동기 - async
   - 서버상태 - server state
   - 테스트 - test

### 비동기 프로그래밍이 어려운 이유
- 프로그램이 작성한 순서대로 동작하지 않는다
- 결과를 예측할 수가 없고 성공과 실패, 로딩중과 캐시 등의 다양한 분기를 가진다
- 비동기 겨로가의 순서를 조정해야 할 필요가 생긴다
- 낮은 예측성, 강한 결합도를 가진 복잡한 코드
- 유연하지 못하고 디버깅이 어려운 코드
- 문제는 UI가 곧 비동기라는 것

#### 복잡한 비동기 Push 방식으로 풀어보자
- 같은 구성이라도 Push 관점으로 바라보면 작업이 간단해집니다
- 모듈 내 역할만 수행하고 생성한 데이터와 제어권을 다른 모듈에게 위임하는 방식
- 하나의 거대한 관리자 모듈이 필요없기 때문에 모듈의 의존성이 낮고 간결해진다

##### 의존성과 결합도가 높아지는 Pull 방식
- 순서대로 하나의 흐름만 제어하는 경우 적합한 방식
```JavaScript
// A.js
export const onClick = async () => {
  B.doSomethingB();
  await C.doSomethingC();
  await D.doSomethingD();
}

// B.js
export const doSomethingB = () => {
  // ...
}

// C.js
export const doSomethingC = async () => {
  // ...
}

// D.js
export const doSomethingD = async () => {
  // ...
}
```

##### 느슨한 결합이 가능한 Push 방식
- 제어의 역전으로 느슨한 결합
- 결합도 down, 응집도 up
```JavaScript
// A.js
const onClick = (e) => dispatch(A(e));

// B.js
on(A)
  .tab(e => doSomethingB(e))
  .createEffect();

// C.js
on(A)
  .tab(e => doSomethingC(e))
  .createEffect();

// D.js
on(A)
  .tab(e => doSomethingD(e))
  .createEffect();
```

##### Pull 방식에서 비동기 처리와 try ~ catch
- 결합도가 높아져서 Massive Function이 될 확률이 높다
```JavaScript
const fetchUsers = http.get('/users');

try {
  const users = await fetchUsers();
  캐시에_보관('users', users);
  토스트_팝업('회원정보를 불러왔습니다.');
} catch (err) {
  캐시에서_삭제('users');
  토스트_팝업('회원정보 불러오기 실패');
}
```

##### 비동기 Action으로 Action을 Reducer로
- Push 방식으로 자유롭게 코드를 배치할 수 있어 모듈별로 응집도를 높일 수 있다
```JavaScript
// Intent
const onClick = () => dispatch(_회원정보_불러오기());

// Service
export const fetchUsers = () => http.get('/users');

// Service -> Action
on(_회원정보_불러오기)
  .exghustMap(() => dispatch(_회원정보_불러오기.REQUEST, fetchUsers()))
  .createEffect()

// Reducer
const users$ = reducer([], 'users$', users$ => {
  on(_회원정보_불러오기.SUCCESS)
    .writeTo(users$)
})

// 토스트 story
story('토스트 팝업', () => {
  on(_회원정보_불러오기.SUCCESS)
    .dispatch(_토스트_팝업('회원정보를 불러왔습니다.'));

  on(_회원정보_불러오기.FAILURE)
    .dispatch(_토스트_팝업('오류가 발생했습니다.'));
})

// 캐시 story
story('캐시 플러그인', () => {
  on(_회원정보_불러오기.SUCCESS)
    .tab((users) => 캐시에_보관('users', users))
    .createEffect();

  on(_회원정보_불러오기.FAILURE)
    .tab(() => 캐시에서_삭제('users'))
    .createEffect();
})
```

> 비동기에 액션을 결합하면 코드를 원하는 대로 배치할 수 있다
> Rx의 Observalble도 연동하여 스트림 비동기 동작도 간단하게 연동

### 서버 상태 관리

#### 엔티티와 거대한 중첩된 객체 다루기
```JavaScript
// 일정 참석으로 변경
const calendarId = '123456';
const eventId = '1234';

return {
  ...state,
  calenders: {
    ...state.calenders,
    [calendarId]: {
      ...state.calenders[calendarId],
      events: {
        ...state.calenders[calendarId].events
        [eventId]: {
          ...state.calenders[calendarId].events[eventId],
          responseState: 'accepted',
        },
      },
    },
  },
};
```

#### Array에서 불변성을 다루기 위한 코드
```JavaScript
const addTodo = (todo) => [...todos, todo];
const removeTodo = (todo) => todos.filter((t) => t.id === todo.id);
const insertTodo = (todo, index) => [...todos.slice(0, index), todo, ...todos.slice(index)];
```

#### 불변성과 중첩된 객체를 다루기 위한 라이브러리
- immer.js, imutable.js

#### Firebase를 연동하면서 배운 것들
- path를 이용한 중첩된 객체 다루기
- path별로 Atom이 될 수 있다
- Array 보다 Key-Value Object로 다루기
- Collection을 Object.values와 sort로 다룬다
- => path를 기반으로 하는 Reactive한 database API를 만들자

#### GraphQL에서 영감을 얻다
- 스키마를 중심으로 개발하자
- query와 mutation을 나눠서 생각하자
- query = (props) => selector
- gql과 같이 Query를 만들어보자

## 카카오워크웹파트 사용 후기

### 좋았던 점
- 데이터를 다루는 흐름을 자연스럽게 이해할 수 있었다
- 개발할 때 지금 어느 단계의 데이터를 어떻게 만들고 전달해야 하는지 알 수 있다
- 자동으로 로깅이 되어 디버깅을 하기에 수월했다
- 문제가 발생했을 때 언제 어떻게 데이터가 수정이 되었는지 알 수 있어서 디버깅하기에 좋았다
- 복잡하게 생각하지 않을 수 있게 해줘서 좋았다
- 이미 만들어진 체계 위에 새로운 기능을 확정하거나 수정하기에 용이했다

## 배운점, 그리고 향후 로드맵

### 배운 것
- 복잡함에는 이유가 있다
- 개념은 복잡해도 문법은 단순하게 만들 수 있다
- 복잡한 구조도 단순한 관점으로 바라볼 수 있다
- 체계가 곧 컨벤션이 될 수 있다
- 계층을 더 잘게 만들어 둘 수록 복잡해지지만 더 단순하게 생각하게 만들어준다
- 계층이 곧 컨벤션이 되고 이는 클린코드로 이어진다

### 현재 개발하고 있는 것들
- Devtools
- User Input Database
- LocalStorage, IndexedDB와 같은 스토리지 기반 자동 연동
- 낙관적 업데이트를 위한 트랜잭션 API
- React에서도 쓸 수 있도록
- Test Library와 TDD
