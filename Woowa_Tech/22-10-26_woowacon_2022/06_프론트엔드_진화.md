# 배민 커머스, 프론트엔드 진화!
- [Youtube](https://www.youtube.com/watch?v=s1z17gCFd6Q)

## 이야기할 내용
- 배민마켓(B마트)부터 지금 배민스토어 웹 프론트개발팀까지
- 코드 레벨의 이야기보다 프론트엔드 조직 관점의 이야기
- 프론트엔드 개발자 0명에서 14명까지의 아키텍처 변화

### 이런 분들에게 좋아요
- 프론트엔드 **조직이 커가는 과정**이 궁금하신 분
- 프론트엔드 **조직을 만들어야 하는 상황**에 있으신 분
- 조직은 커지는데 **앞으로 어떤 일을 해야할지** 고민하시는 분

## 시작, 프론트엔드
- 고객의 니즈를 빠르게 파악하여 시장을 선점하기 위한 웹 프론트 환경 구성

### 커머스의 시작, 배민마켓
- 배민에서 시작한 첫 B2C 커머스 서비스

### 당시 배민 마켓 상황
- Java Spring 기반 서버 개발자
   - 프론트를 전문적으로 해보지 않음 => 이전 프로젝트에서 Vue를 사용해본 경험이 있음
- Android 개발자 / iOS 개발자 1명씩
   - 앱 개발 하기에도 벅찬 상황
- 웹 프론트 개발자 없음

#### Vue
- Vue 2.0 릴리즈 이후 3년 -> 안정적
- 여러 컨퍼런스에서 Vue의 발표가 활발히 일어나고 있었음
- 내부 개발자들의 이번 프로젝트 경험

### 만들어야 할 프로젝트
- 웹앱
- 임직원 어드민
- 다크스토어 어드민

#### 웹앱
- 장바구니, 주문, 상품 페이지
- 온갖 써드파티 모듈의 대환장 디버깅 파티 (feat. 하위버전 디바이스)

#### 임직원 어드민
- B마트의 대략 흐름
- 업체 컨텍 -> 상품 등록 -> 상품 입고 -> 전시 -> 센터 출고 -> 배달 -> 도착
- 상품 등록 및 전시를 제어할 수 있어야 한다
- 프로모션 / 쿠폰 / 주문 등 다양한 정보를 열람할 수 있어야 한다

#### 다크스토어 어드민
- 현지에서 운영하는 물류센터의 직원이 사용하는 페이지
- 다크스토어 내에서 물류를 관리할 수 있는 어드민
- 센터 내 임직원이 사용하여 현재 배달 및 물품 재고 현황을 관리

### 프론트, 홀로서기

#### 상황
- 자바 기반 백엔드 레포지토리에 함께 포함
- 웹 프론트엔드 인력 부족으로 하나의 레포지토리에서 함께 관리
- 웹 프론트엔드 개발자 입사

#### 서버 개발자 리소스 과중을 줄이기 위해
- 빠르게 사용자의 기능을 확장하는 웹앱 영역을 분리
- VOC 인입 및 많은 피쳐 개발의 오너쉽 분리
- 물리적인 레포지토리 분리

#### 레포지토리 분리하기

##### 조직 관점
- 레포지토리만 전문적으로 담당하는 개발자에게 오너쉽 이관
- 오너쉽 이관은 연관된 업무를 기존 역할자로부터 분리
- 집중해야 할 목표를 모듈별로 분리함으로써 생산성 향상

##### 분리를 하기 위한 고려사항
- 인프라도 해당 코드의 목적에 따라 변동이 필요
- 롤백 시나리오는 꼭 필요하며, 운영에 지장이 없도록 준비
   - 새로운 인프라 환경을 만드렁 테스트 준비
   - 테스트를 거친 후, 운영으로 전환

#### 분리해서 무엇을 얻었는가?

##### 독립성
- 코드 관리 방식을 독립적으로 운용 가능
   - 그라운드 룰이나 Git을 다루는 방식은 서비스 / 프로젝트 / 개발 직군에 따라 다르다

##### 리소스 효율화
- 프론트엔드 업무의 범위를 레포지토리 및 인프라 단위로 명확하게 정하면서, 관련 업무를 프론트엔드 개발자가 할 수 있도록 격리, 개발자 업무 효율화

##### 포인트
- 프로젝트의 규모 / 인원에 따라서 결정
- 인원이 적을 때 분리하면 오히려 개발 시간이 늘어날 수 있다

### 개편, B마트!
- 앞으로 들어올 프론트엔드 개발자와 성장을 위한 아키텍처 변경

#### 도메인 단위 컴포넌트
- 작은 프로덕트는 한 눈에 기능 확인 가능
- 큰 프로덕트면 중복된 로직이 많아짐
   - common 폴더 운용으로 해결 가능
- 비슷한 도메인이 페이지별로 많아지면 찾기 어려워진다

##### 프로젝트 하나, 5개 페이지 미만에 적합한 구조
- 5개 페이지에 기능이 많이 없는 시작 지점의 프로젝트에는 용이하다
- 한 눈에 볼 수 있고 빠르게 수정할 수 있기 때문
- 동일한 도메이느이 페이지가 많아지고 다양한 뷰가 많아지면 대응하기 어렵다
- 다양한 페이지의 중복 로직을 모두 Common에서 Depth없이 수용하게 된다.

##### 어떻게 개선해야 할까?
- 컴포넌트의 종류에 따라 분리의 필요
   - 공통 레이아웃도 여러 종류가 존재
   - 레이아웃 컴포넌트의 분리가 필요
- 컴포넌트에 비즈니와 여러 ㅗㄹ직이 함께 존재해서 로직 이해가 어려움
   - 로직의 종류에 따라 분리가 필요해짐

#### 컴포넌트 계층과 종류 나누기
- Atomic Design
   - atoms, molecules, organisms, templates
      - 생략하거나 추가를 함으로써 재사요을 위한 컴포넌트 계층을 만든다
- Container & Presentationals
   - 컴포넌트 분리를 위해 함께 작성한 비즈니스 로직을 분리
   - Container에 비즈니스 로직, Presentationals에 레이아웃
   - React 16.8부터 hooks가 있지만, Vue2는 파일 단위로 분리

##### 개편 이후를 위해 확장성 있는 구조로 변경
- Atomic Design과 Container & Presentationals 패턴을 응용하여 3~4명 정도가 여유롭게 작업할 수 있는 구조
- 검증이 실패한 코드를 변경하거나, 파기해야 하므로 영향도가 적고 공통적으로 사용할 수 있게 코드 구조 변경

##### 문제가 발생하는 지점
- 프론트엔드 만의 정책을 수정하여 레이아웃은 동일하지만 핵심 로직만 변경하거나 UI를 빠르게 수정해 배포를 진행하는 경우가 자주 생긴다
- Contianer 컴포넌트가 비즈니스가 빨라질수록 더 많아지고, 그대로 재사용이 되지 않는 경우가 생긴다

##### 당분간 유지할 아키텍처
- API, Store
   - 서버, 공통 데이터를 Container에 전달
- Container & Model
   - 데이터를 레이아웃에 맞게 포팅
   - 모델에서 결과를 만들어 하위로 전달
- Page
   - Container <-> Template 통신 계층
- Template, Organisms, Molecules, Atoms
   - 레이아웃 재사용을 위한 컴포넌트
   - 데이터에 따라 렌더링

### React로의 점진적인 이동
- 채용, 커뮤니티, 전사 기술 스택을 따라가기 위해

#### 개편도 했고, 아키텍처 잡았고, 남은 것은?
- 많은 인원이 작업할 수 있는 아키텍처 수립
- B마트 리브랜딩 - 퀵커머스
- 채용 진행하자

#### 채용에 앞서
- 시장에서 프론트엔드 개발자는 어떤 기술을 사용할까?
- 현재 가장 인기 있는 기술 스택, 커뮤니티 크기
- 우리가 사용하고 있는 기술과 어떤게 차이가 있을까?
- 대다수의 회사는 React를 사용
   - 채용에 React가 유리할 수 밖에 없다

#### 기술은 언제든 변화할 수 있어야 한다
- 현재 개발 조직이 Vue를 좋아하건, Angular를 좋아하건 중요하지 않다
- 좋아하는 것과 별개로 프로덕트의 지속가능성의 측면에서 기술 고민을 해야 한다.
- 팀에 Vue 개발자가 있고, 빠르게 프로덕트를 만드렁야 한다
   - 당장은 Vue를 쓰는게 적합
   - **장기적으로 옳은 판단**인가?
   - **채용 / 유지보수 / 커뮤니티 등 다양한 관점에서 보고 기술을 고집하지 않기**

#### 결론
- 시장에서 Vue 개발자는 찾기 어렵고, React 진영에서 굳이 Vue로 넘어올 이유 X
- 그러므로 **React로 옮기는게 맞다**

#### Vue에서 React로 옮기려면

##### 프로덕트 관점
- Vue 특화된 코드를 React로 포팅할 수 있는가?
- 현재 아키텍처를 수립하는데 적합한 React 문법이 존재하는가?
- 어느 범위부터 이관할 것인가?

##### 기술 선택
- CRA VS Next VS ..?
- 상태 관리 라이브러리
   - Vue는 Vuex(2022 기준, Pinia) 단일이지만, React는 다양함

##### 조직 관점
- 팀원들의 React에 익숙해지기 위한 러닝커브 고려
- Vue 코드 유지보수 인원 / React 신규 개발 인원 분리

##### 적용하기 위한 도메인 분리
- 주문, 상품 두 도메인으로 분리 가능
- 주문 도메인
   - 전체 웹페이지 중 대부분
   - 도메인에 특화된 비즈니스 로직 다수
   - 배민페이 등 내/외부 라이브러리 적용
- 상품 도메인
   - 상품 상세 피이지 (상품 컨텐츠, 상품 정보, 교환 반품 정책 등)
   - 비즈니스 로직 없음
   - 상품을 분리해서 React로 마이그레이션 하기

##### 상품 도메인은
- 페이지 4개 (상품 컨텐츠, 상품 정보 제공 고시, 교환 및 반품 정책 등)
- 복잡한 상태, 비즈니스 등 존재하지 않음
- API 호출 적음
- React 시험 프로젝트로 적합하다 판단

##### 기술 스택은
- 페이지가 빠르게 나오지 않아도 됨 => SSR 필요 없음
- 요구사항이 어렵지 않음 => 단순한 기술 스택으로 문제 해결 가능
- Create React App => 팀의 첫 React 프로젝트에 적합
- 단순하므로 추가 챌린지 => TypeScript 도입

##### 첫 React + TypeScript 프로젝트
- 올바르게 React를 사용한 것인지, 알 수 있는 시행착오 과정 필요
- 빠르게 만들고 유지보수에 적합한 아키텍처를 확인해야 할 필요
- 팀 내 기술 숙련도 향상 / 노하우 축정 필요

##### 숙련도 향상을 위해
- 비즈니스와 연관된 개선을 과제로 주도적 제작을 통한 숙련도 향상
   - 프로모션 페이지 메이커
   - 개발자 어드민
   - ...
- 성장할 수 있는 여러 프로젝트를 비즈니스와 결합하여 성장하기

##### 아키텍처를 리액트로 변경하기
- v16.8 버전 이후 Hooks의 등장
- Custom Hooks를 사용한 계층 분리
- 공통 커스텀 훅과 모델을 조합한 Page에 1:1 대응하는 비즈니스 커스텀 훅

##### 변경점
- 크게 달라지는 것 없이 로직의 이동만 진행
- 커스텀 훅으로 API 및 Store 가져오는 로직을 구성
- 데이터와 모델을 조합하여 Business Custom Hooks 중간 계층에서 페이지의 비즈니스 로직 생성

##### React 마이그레이션의 초석을 통해
- 채용 / 트랜드 / 커뮤니티 등 다양한 방면에서 이점을 누리는 라이브러리 변경
- 늘어나느 프로덕트를 동일한 아키텍처로써 프레임워크가 달라도 팀원이 익숙하게 개발할 수 있게
- 기술 챌린지를 팀 내부적으로 부여해 성공적인 작업을 할 수 있도록

##### 앞으로 남은 작업
- 남은 프로젝트 리액트 마이그레이션
- 트랜드와 채용을 고려한 팀 내 기술 챌린지 지속적 부여

### 완전한 React 이관과 SSR
- Vue를 완전히 Fade Out, SSR과 함께 모든 프로젝트 React 적용하기

#### 우아한형제들의 피트스탑 문화의 시작
- 매 년 8월, 비즈니스를 멈추고 쌓여있는 기술부채를 해결하는 시간을 가짐, **피트스탑(Pit-stop)**

#### 피트스탑 기간을 이용한 완전한 전환
- 메이저 작업
   - 주문 도메인의 Vue -> React 마이그레이션 작업
   - 주문 렌더링 속도 (FCP) 개선
- 마이너 작업
   - 기존 자바스크립트 비즈니스 로직 타입스크립트 도입
      - 타입스크립트의 점진적 패러다임을 통해 개발하면서 도입해도 무방
   - 앱/웹 브릿지 (인터페이스) 규칙 재정의
      - 이 또한 점진적으로 도입해도 무방
      - 자세한 사항은 다음 영상 참조. [Youtube](https://www.youtube.com/watch?v=q_NBDCtZaQU)

##### 주문 도메인 Vue -> React 마이그레이션
- 정해진 아키텍처로  폴더 계층 구조 수정
- 컴포넌트 리액트화
   - Vue의 watch, computed 등 비동기로 존재하는 로직중 메모이제이션이 필요한 부분을 추출해, useMemo, useCallback 등으로 변경
   - Vuex -> Redux 변경
   - Vue와 React의 문법적 / 아키텍처 적 간극에서 오는 부분 보완하기
- 비즈니스 로직(모델) 이동
- 개발자 테스트 및 Full TC QA 진행

##### 주문 렌더링 속도 (FCP) 개선
- 가장 큰 문제는 번들링 된 SPA 앱의 빌드 파일을 페이지마다 호출하는 것
   - 페이지 단위로 사용하는 로직만 추출해 최적화한 빌드 Asset 만들기
   - 라우트 별로 빌드 Asset 별도로 호출할 수 있도록
   - 라우트간 상태 공유는 어떻게?
- 자바스크립트 로드되고 보이는 것이 아닌, 그 이전에 최소 레이아웃을 노출
   - FCP 속도 향상
   - 서버에서 페이지 벼롤 캐싱해두면 빠르지 않을까?

##### React + SSR
- 장점
   - 핫한 트랜드의 기술 주제 (Next.js가 각광 받을 무렵), 채용에 이점
   - 사용자에게 서버 사이드 렌더링을 통한 더 빠른 FCP
   - 노드 서버를 통한 브라우저를 포함한 개발 선택지의 확장
   - 기술적인 챌린지를 팀에 부여 가능
      - 노드 서버 운영 능력 / 서버 사이드 렌더링에 대한 지식 등
- 단점
   - 프론트 개발자의 할 일이 늘어남 (노드 서버 모니터링, AWS 유지 보수 등)
   - 사실 굳이 할 필요 없는 업무를 늘리는 것 (SPA로 개발하거나 웹팩 커스텀 빌드를 통해 진행해도 50ms 내 제공 가능)

##### 얻는 이점이 많기에 진행하기
- 기술 스택 선정하기
- React + Loadable Component
   - Webpack 커스텀 설정 및 Loadable Component로 Hydration 시키기
   - 많은 설정 필요, 정보 많이 없음
   - 노드 서버 설저옫 직접 해야 함
- Next.js
   - 프레임워크로써 이미 보장된 기술을 사용
   - 많은 설정을 사용하지 않아도 간단하게 사용 가능
   - 노드 서버 설정도 어느정도 지원 (직접 만질 일 없음)
- SSR 기술을 근본부터 설정해보고 어떤 이점이 있는지 알기 위해, Loadable Component 선택

##### 완전한 React 이관과 SSR
- 피트스탑 문화로 React 마이그레이션 진행
- React 전환 후 지원율 평균 12배 향상
- React + Loadable Component와 같이 메이저하지 않은 기술을 선택하고 근본을 학습하는 것은 프로덕트 규모가 작을 때는 유효, 서비스가 크다면 안정적인 것으로 교체하는 것을 추천.
- 인프라에 쓰는 여러 데이터는 대다수 CloudFront를 사용하여 캐싱 -> 비용 축소 및 절감 -> Cache Invalidation 관리를 잘해야 함

### Presentational 계층 개선
- 디자인 컴포넌트 라이브러리 적용을 통한 관심사 분리 및 레포지토리 단위 중복코드 개선

#### Atomic Design 분리하기
- 레포지토리 하나에선 좋은데, 각 프로덕트 별로 상황이 너무 다르므로, 일관적인 적용이 어려움
- 모든 프로덕트에 디자이너와 계속 붙어서 일관적인 커뮤니케이션이 가능하다면 좋지만, **불가능**
- **디자이너와 최소 단위로 논의하는 범위를 정해서 분리 관리를 하는 것이 낫다**
- **Molecuels / Atmos 정도를 분리해, 디자인 시스템이라고 명칭하자.**

### 정리
- 배민마켓부터 B마트까지 프론트엔드 챕터가 홀로 서기 위한 여정
- 한 챕터로써 성장을 하기 위해선 팀원의 기술 숙련도 향상과 채용이 필요
- 기술 숙련도 향상을 위한 React 커뮤니티 진입 및 아키테겇 분리를 통한 도메인 집중
- 채용률 향상을 위한 발빠른 트랜드 적용 및 성공 & 실패 케이스 추출하기
- 비즈니스에 연관됨 자체 과제를 발의하여 성과 + 팀 력량 향상 시키기
- 지속가능한 거시적인 아키텍처를 설계하고 문제 해결하기

## 안정적인 프론트엔드 팀으로
- 많은 프론트엔드 개발자가 안정적인 업무를 진행해 비즈니스를 유연하게 대응하려면
- 기획 + 프론트 + 백엔드 + 디자인 / 목적 조직 구성

### 커질수록 다양하고 어려운 문제가 발생한다
- 프로덕트가 커질수록 중복 및 레거시 코드를 개선하는 작업이 일어난다.
- 이 과정에서 코드의 응집이나 프로젝트를 여러 테크닉과 기술을 사용해 문제를 해결해야 한다.
- 아키텍처 제작, 레거시 코드 개선, 툴 개발, 빌드 시스템, 테스팅 환경 등

### 높은 수준의 문제를 해결하기 위해 집중하기
- 동일한 도메인의 프로덕트를 한 데 모으고, 동일한 문제를 집중시켜 해결
- 컴포넌트를 고수준으로 만들어 동일한 마크업 및 로직을 재사용하기
- 도메인을 모두 공유하며, 모든 사람이 모든 작업을 할 수 있도록 도메인 담위 담당자에서 분리시키기

### 업무 방식의 변화
- 거대한 몸이 되어가는 프론트엔드 팀의 업무 방식을 변화시키기

#### 혼자 일하는 것과 여러명이 일하는 것은 다르다
- 업무의 크기마다 다르겠지만 대부분의 경우 여러명이 하는 작업이 더 빠르다
- 업무가 달라지거나 외부의 요인이 있는경우
   - 혼자 일하는 경우 상대적으로 자유롭다. 그러므로 더 빠르게 전환이 가능하다
   - 여러명이서 일하는 경우, 이미 정해놓은 약속 등이 있으므로 전환이 어렵다

#### 그렇기에 업무 방식이 정해져야 한다
- 인원이 많아질수록 많은 업무를 처리할 수 있다
- 많은 업무를 처리할 수 있지만 갑작스러운 변경은 오히려 혼자 하는 것보다 퍼포먼스가 저하될 수 있다

#### 업무의 진행 순서
- 업무 요청 프로세스 & 업무 생성 프로세스 -> 현재 스프린트
- 현재 스프린트: 티켓 기반 작업
- 스프린트 기간 종료: 종료된 스프린트 작업 확인 및 배포
- 스프린트 완료 & 회고: 완료 스프린트에서 미완료 작업 전달
- 새로운 스프린트 추가

#### 사전 단계
- 업무 요청
   - 개발 담당자 설정: 일정이 비어 있는 개발 담당자
   - 개발 담당자와 기획 리뷰
   - 해당 일정에 업무 추가
- 업무 생성
   - 생각날 때마다 어딘가에 작성해두기
   - 일정이 비었을 때 해당 작업 진행
   - 일정에 업무 추가

##### 사전 단계 w/ Jira
- 업무 요청
   - 개발 담당자 설정: 지라로 일정 확인
   - 개발 담당자와 기획 리뷰
   - 업무 Jira Ticket 전달
- 업무 생성
   - 생각날 때마다 Jira Backlog
   - 일정이 비었을 때 현재 스프린트 추가

### 프론트엔드 문화 만들기
- 자동화, 문서화 등 문화를 도입하고 발전할 수 있는 환경 만들기

#### 문화는 팀이 어떤 팀인지 이야기한다
- 작게는 개발 방법이라 이야기할 수도 있고, 크게는 팀의 설명일 수 있다
- 문화가 잘 구추고디어 있다면 팀원 및 팀 단위의 성장으로 많은 성과를 이룰 수 있다
- 팀의 문화는 회사의 문화아 다르게 팀원의 수나 방향에 따라 크게 달라질 수 있다
   - 언제든지 문화는 사라질 수 있고, 새로운 문화를 적용할 수도 있다
   - 회사 단위의 문화보다 더 작은 단위로 동작하기 때문

#### 조직 문화와 개발 문화
- 문화를 나누면 조직 문화아 개발 문화 두 가지로 분류할 수 있다
- 조직 문화는 팀원이 **행동하면서 지켜야 하는 문화**를 일컫는다
- 개발 문화는 팀원이 **개발하면서 지켜야 하는 문화**를 일컫는다

#### 문화는 생각하지 않아도 지켜지도록 해야 하낟
- 조직 문화와 개발 문화는 각자 다른 방향으로 성장하지만, 의도하지 않아도 잘 지켜지도록 해야 한다
- 목표는 **의식하지 않아도 문화를 발전시키면서 잘 지키도록 하는 것**

##### 조직 문화
- 주간 / 분기 / 프로젝트 회고
- 정보 공유
- 온보딩 프로세스
- 문서화
- ...

##### 개발 문화
- 코딩 컨벤션
- 코딩 리뷰 규칙
- 배포 규칙
- Git Branch 정책
- ...

#### 자동화된 시스템과 알람
- 규칙은 많을수록, 복잡할수록 외우기 어렵다
- 생활하면서 도움을 주는 여러가지 도구와 트리거로 지킬 수 있도록 제공한다

#### 코드 리뷰 활성화를 위해
- 오전 집중 코드 리뷰 시간
- 자동 배정된 리뷰어에게 알림
- 출근 후 바로 코드리뷰를 진행
- 코드 품질 향상 & 팀원의 성장
- [코드리뷰 문화](./08_%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.md)

#### 온전히 작업에만 집중할 수 있도록
- 정해진 Git Branch 전략과 배포 환경
- 코드 자동 rebase & merge
- 코드 자동 dev 환경 및 storybook 배포
- 프로세스만 이해하면 그 외의 것은 지키도록 자동화

#### 1 Pager를 통한 과제 사전 검토 및 기록하기
- 어떤 작업에 대한 기록은 없는 것보다 있는게 유리하다
- 동일한 규격으로 누구든 열람할 수 있도록 제공하며 쉽게 기록할 수 있도록 해야 한다
- 이러한 문서를 1 Pager라고 하며, 작업 시작할 때 템플릿을 복사해서 기록한다

##### 프로젝트 단위 1 Pager 작성
- 연관된 지라 문서 기획 논의사항 기록
- 작업만 하면 되는 거소가 주도적으로 작업한 것을 분리
- 끝으로 프로젝트 회고까지 진행
- 성과를 명확하게 만들도록 한다

#### 결론
- 문화는 **의식하지 않아도 발전시키면서 잘 지키도록 해야 한다**
- 자동화와 알람, 템플릿을 복사하는 반복적인 `리추얼`을 통해 지켜지도록 한다
- **문화가 지켜지기 위해**
   - **팀원의 적극적인 참여**
   - **어떤 이야기든 할 수 있는 환경의 조성이 필요**

### 아키텍처 = 프로덕트 + 팀원
- 프로덕트와 팀원에 따른 아키텍처 수립

#### 아키텍처는 규모에 따라 결정된다
- 아키텍처는 프로덕트의 개수, 팀원의 수 등 현재 개발 환경에 결정
- 인원 수 한 명이 모듈 수십개로 쪼개진 프로덕트를 지탱할 순 없다
- 반대로 하나의 프로덕트를 수십명이 변경하는 것은 굉장히 어렵다
- 적합한 인원에 적합한 프로덕트 구조를 만들어 입무를 부여하는 것이 중요하다
- 아키텍처는 프로덕트의 구조와 인원 배치를 고려해 설계한다

#### 프론트엔드에서 아키텍처는?
- 프로덕트 내의 폴더 스트럭처, 모듈의 분리된 형상
- 프로덕트가 유저에게 전달되는 서버 인프라
- 관심사에 따른 레포지토리의 사용 구조

#### 공통 스토어 아키텍처
- API, Store, Page를 분리한 아키텍처
- Redux/React, Vue/Vuex
- Container로 Business 로직을 분리
- 단방향 구조로 수정부를 알기 쉽다
- 소수의 인원이 여러 상태를 바꾸기 용이

##### 단점
- Page와 API는 수평확장이 가능하다
- 하지만 Store는 페이지가 많아지고 상태가 많아질수록 복잡해진다
- Store에 의존적이지 않고, API와 페이지가 바로 매칭되면 오버헤드를 줄일 수 있다

#### 페이지 단위 아키텍처 변경
- 팀원이 3명 이상, 프로덕트가 어느저옫 커졌을 경우 페이지 별 담당자를 정하는 경우 용이
- MobX와 같은 라이브러리로 페이지 별 상태 관리를 해도 비슷한 효과를 낸다
- 비즈니스 로직을 각 컴포넌트에 대응하는 훅에서 작성

##### 인원이 많아지면 페이지 단위로 쪼개기
- 가장 단순하게 해결할 수 있는 ㅂ아법
- 하나의 프로덕트를 소수의 인원이 담당하기 위한 공통 상태를 각 페이지별로 분리
- 스토어는 최대한 **공통 상태만** 들고 있도록 한다. e.g. 유저, 캐싱 데이터
- API 데이터를 페이지 단위로 잘 처리하기 위해 react-query, swr과 같은 모듈을 사용하면 더 좋다 (+ React v18 suspense로 에러 처리까지)

#### 다음 아키텍처를 생각해야 할 때
- 팀의 인원에 맞는 업무량(리소스) > 업무
   - 업무에 비해서 팀의 인원의 퍼포먼스가 더 잘 나오는 경우
- 팀 인원에 비해 리소스 효율이 나오지 않는 경우
   - 어딘가에서 중복 로직이나 효율적이지 못한 부분을 분리/개선 필요
- 공통적으로 분리할 수 있는 부분을 분리하기
   - 새로운 레포지토리가 될 수도 있고, 폴더일 수도 있다

#### 공통 컴포넌트 분리
- 리소스가 많이 수반되는 작업이다
- 모든 페이지의 **사용성**에 영향
   - 사용자의 사용에 영향을 끼치므로 QA 프로세스 및 테스트 필요
- Android / iOS / Browser 별 영향도가 존재
   - 크로스 브라우징 관련된 확인 필요
- 공통 컴포넌트는 **디자인 규칙**에 따른다
   - 디자이너와 컴포넌트에 대한 규칙을 정해서 작업하지 않으면 나중에 변경확률이 커진다
- 사용처에 따라 DI의 Interface가 달라질 수 있다
   - 팀 내의 CDD 및 컴포넌트 개발 숙련도가 낮은 경우 Interface가 계속 변경될 수 있다

#### 컴포넌트는 빈번하게 변경되지 않아야 한다
- 컴포넌트는 변화가 바로 **프로덕트에 적용되면 위험**하다
- 작업하면서 **컴포넌트에 부족한 기능**이 보여도 계속 **추가하거나 수정하면 안된다**
   - 공통 컴포넌트는 **모든 페이지에 영향**을 주기 때문
- 컴포넌트의 변경점은 **히스토리가 버전 단위로 배포**되어, **버전 단위로 사용**하는게 이상적이다

#### 컴포넌트를 프로젝트에서 분리하기
- Rollup, Webpack, Parcel, Microbundle 등 번들러를 이용해 NPM Library로 만들기 (사내 Nexus가 있다면 이용하기)
- 프로젝트에서 분리되면 해당 컴포넌트만 관리하는 인원을 별도로 둘 수 있다
- 버전 관리가 되어 프로젝트 담당자와 논의 후 버전을 올리거나 할 수 있다
- 라이브러리의 버전이 올라가면 QA 협의 등을 통해 전수 테스트 진행
- 라이브러리 기준 단위 / 컴포넌트 / 시각적 회의 테스트 고도화 가능

> 일반적으로 별도로 분리된 컴포넌트 모음을 디자인 시스템이라 명칭

#### 수평적으로 증가하는 프로덕트 대응
- Gray Zone의 출현
   - 디자인 ㅋ넘포넌트 라이브러리는 아닌데, 여러 프로덕트에서 함께 쓰여야 하는 것들 (컴포넌트, 비즈니스 로직, 모델, 훅...)
- 서로 달라지는 프로덕트 환경
   - 코딩, 컴포넌트 규칙
   - 프로덕트 간 팀원의 이해 간극이 커짐

#### 어드민과 앱 서비스는 진화 반향이 다르다
- 어드민 서비스는 **업무 단계**에서 **효율적으로 많은 데이터**를 **쉽게 조작**할 수 있어야 한다
- 앱 서비스는 **쉽고 빠르게 사용하고, 상품을 추천하고 제공**할 수 있어야 한다

##### 어드민 서비스
- 일관된 업무 경험 보장
- 많은 데이터를 쉽고 빠르게
- 서비스에 1:N으로 매칭되는 프로덕트
- 별도의 의존성이 없는 오직 웹 서비스
- ...

##### 앱 서비스
- 서비스 별 다른 사용 경험
- 많은 데이터를 매력적으로
- 빠른 유저 경험을 얻기 위한 개발 & 유지보수
- 앱과의 의존성으로 인한 네이티브 로직 대응 필요
- ...

#### 플랫폼과 서비스, 비슷한 로직을 묶이 위한 모노레포
- [모노레포 with pnpm](./05_%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC.md)

## 미래
- 배민 커머스, 프론트엔드의 미래를 살펴보기

### 배민 스토어 웹 프론트개발팀이 핲으로 해야 할일
- 팀 문화
   - 코드 리뷰 문화
   - 자동화된 업무 프로세스
   - 팀 내 스터디
   - 문서화
   - ...
- 빠른 개발을 위한 생산성
   - 보일러 플레이트
   - 아키텍처를 통한 중복 로직 개선
   - 디자인 시스템
   - 자동화 툴 개발
   - ...
- 안정적인 서비스 운영
   - 테스트
   - 인프라
   - 모니터링
   - 서버 개발
   - ...

### 팀 문화
- 자동화와 연계된 업무 프로세스로 업무에 집중할 수 있는 환경 지속
   - 업무 발행, 코드 리뷰, Git, 배포, QA 등의 자동화
- 성장을 위한 환경 지속
   - OKR / 라이트닝 톡 / 자유주제 워크숍 / 팀 내 스터디
- 함께 알기 위한 환경 지속
   - 문서화 (1 Pager) / 프로젝트, 주간 회고

### 빠른 개발을 위한 생산성
- 손쉬운 수평적 확장을 위해
   - 보일러 플레이트 / 디자인 시스템 / 라이브러리 등
- 반복적인 업무를 줄이기 위해
   - 컨텐츠 에디터 / 배민쇼핑라이브 영상 편집 툴 / 여러 업무 지원 툴
- 여러 프로덕트를 손쉽게 관리하기 위해
   - 모노레포 / CLI / DX 고도화

### 안정적인 서비스 운영
- 서버 데이터를 안정적으로 받기 위해
   - BFF로 프론트엔드를 위한 결과값을 만들고 캐싱하기
   - GraphQL + Relay와 같은 기술을 통한 데이터 응집
- 서비스 품질 향상을 위해
   - 페이지 별 서버 프리 렌더링 범위를 통해 첫 페이지 로드 속도 향상
   - 번들 용량 최적화, 로직 성능 향상, 리액트 18 기능 적용

>  개발에만 집중할 수 있도록 환경을 구축하기
