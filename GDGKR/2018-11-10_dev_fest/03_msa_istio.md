# 마이크로서비스 아키텍처에 서비스메시 끼얹기(feat. Istio)
- 김충섭, 퍼플웍스

> 마이크로 서비스와 서비스메시 + Istio

## 생산성에 대하여

### 소스가 크고 복잡해질수록 커지는 문제점
- 복잡한 소스 구조
- 느린 빌드 속도
- 오래 걸리는 테스트 코드 실행 + QA
- 자꾸 죽고 느려지는 개발도구
- 업데이트하기 어려운 라이브러리 / 프레임워크 버전
- 단일 언어 / 단일 프레임워크 사용

### 문제를 해결하는 방법
- 더 정교한 프로젝트 설계
- 서버리스 (Serverless)
- 마이크로 서비스 아키텍처(MSA)

### 마이크로서비스 도입
- 모놀리틱 -> 마이크로서비스

#### 희망편
- 잘 설계된 서비스
- 자동화된 프로세스
- 모니터링 / 로깅 / 알람 서비스
- 훌륭한 DevOps 문화
- 빠른 릴리즈
- 원활한 팀 협업

#### 절망편
- 결제 서비스 에러 났는데 하루동안 모름
- 모니터 3대에 터미널 12개 띄움
- 팀간 소통 안됨 / 분열
- 운영 / 배포작업은 한 땀 한 땀 손으로
- 넘치는 버그 / 불가능한 디버깅
- 트랜잭션 오류
- 자주 바뀌는 버전 / 명세

## 왜 서비스 메시인가?

### 단일 시스템에서 분산 시스템으로
- 네트워크 이슈가 발생하기 시작함

### 분산 컴퓨팅에 대한 착오
- 네트워크는 신뢰할 수 있다.
- 레이턴시는 없다.
- 대역폭은 무제한이다.
- 네트워크는 안전하다
- 네트워크 구성은 변하지 않는다.
- etc..

### 안정적인 운영을 위해 필요한 것
A서비스와 B서비스가 통신하다고 가정했을 때,
1. 서킷 브레이커
2. `재시도`
3. 로드밸런서: 분산처리된 서비스에게 로드 밸런싱
4. 서비스 디스커버리: 로드 밸런서에게 분산 서비스의 상태를 알려줌
5. 로그
6. 대시보드

### Retry
- 재시도를 도입하려면, 모든 코드에 재시도가 들어가야 하는데.. 너무나 많은 작업 및 코드 또는 라이브러리 도입을 요구한다.

### No code, Proxy!
- 재시도 횟수 관련 내용을 Proxy에 두고 Proxy의 설정에서 관리하고, Code에서는 `한 번만 호출`

### Linkerd
- JVM / Scala

### envoy
- Lyft에서 C++로 만든 서비스간 통신을 처리하는 고성능 프록시
- 작고 가볍고 빠름

## Istio
- Google, IBM, Lyft 참여
- Kubernetes 연동
- 컨테이너 기반, 클라우드 기반(Cloud Native) 환경에 적합
- Envoy 기반으로 관리기능 추가 + @
  - Envoy에서 설정을 변경하려면 모든 End point에서 수정을 해야 하는데, 이를 개선

### 제공하는 기능
- Routing Management(경로 관리)
- Fault Injection(오류 주입)
- Security(보안)
  - 내부 통신용 HTTP에 TLS 적용
- Distributed Tracing(분산 추적)
- Monitoring(모니터링)
  - Grafana를 대시보드로 사용하여 볼 수 있음
- Observability (feat. Kiali)

### Istio Demo
- [Link](https://github.com/subicura/istio-demo)
- Kubernetes 설치(Docker for Mac)
- Istio

## 결론
- 특정 언어에 종속적이지 않고, 어떤 언어, 어떤 프레임워크에서도 사용할 수 있다.
- 마아크로 서비스에서 클라우드 네이티브 아키텍처로
- Docker + Kubernetes + Istio
