# 라이브러리 개발기 @webtoon/psd
- [Youtube](https://youtu.be/R2pBPqLXZNs?t=80)

## 목차
- [@webtoon/psd](https://github.com/webtoon/psd) 라이브러리 동작과 포토삽 파일 구조
- 라이브러리 성능 개선

## 라이브러리 개발 배경
```JavaScript
<input type="file" accept="image/vnd.adobe.photoshop" />
```
- PSD 파일 정보
   - 이미지 가로/세로 길이
   - 색상 관련 데이터
- 파일에 포함된 레이어 정보
   - 레이어 가로/세로 길이
   - 레이어 좌표값
   - 레이어 이미지 픽셀 데이터

### 웹 어플리케이션에서 포토샵 파일을 읽는 방법?
- 서버에 업로드하여 파일을 분석하고  메타데이터와 이미지 다운로드
   - 개발이 많이 진행된 "psd-tools" 라이브러리 사용 가능 (python 언어로 작성된 라이브러리)
   - 포토샵 파일 용량이 클 경우 업로드/다운로드에서 시간 지연
- 사용자의 웹 브라우저에서 바로 파일을 분석
   - 로컬 환경에서 바로 파일을 분석하므로 네트워크 호출 비용이 없음
   - "psd-tools"만큼 강력한 라이브러리 부재

### 기존 포토샵 관련 라이브러리 - PSD.js
- [pds.js](https://www.npmjs.com/package/psd)
- 기존 라이브러리가 있음에도 사용하지 않은 이유
   - 번들링 용량
   - 실행 속도
   - .psb 형식 미지원
   - 한글/한자 미지원
- webtoon/psd의 개선 사항
   - 약 1/10 크기의 번들링 크기
   - 약 7배 정도 빠른 실행 속도
   - PSB 파일 지원
   - 유니코드 문자 지원

## 포토샵 파일 톺아보기
- [포토샵 파일 명세](https://www.adobe.com/devnet-apps/photoshop/fileformatashtml)
- File Header
   - 정상적인 포토샵 파일인지 여부 판별할 수 있는 정보
   - 이미지의 가로, 세로 길이와 같은 기본 정보
- Color Mode Data: 파일의 색상 관련 정보
- Image Resources: 편집 상태값이나 정보를 담고 있는 섹션 (e.g. GuideLine, Slices, EXIF 등)
- Layer and Mask Information: 레이어(및 레이어 그룹) 정보와 레이어의 이미지 픽셀 데이터, 그리고 적용된 효과 정보를 담고 있는 섹션 (e.g. Offset, Color Overlay 등)
- Image Data: 모든 레이어에 효과를 적용하여 최종 합성된 미리보기 이미지 데이터를 담고 있는 섹션

## 바이너리 데이터를 JavaScript에서 다루기

### ArrayBuffer 객체를 얻는 방법
```HTML
<input type="file" />
```

```JavaScript
const inputEl = document.querySelector('input');

inputEl.addEventListener('change', () => {
  const reader = new FileReader();
  const [file] = inputEl.files;

  reader.addEventListener('load', () => {
    const { result: arrayBuffer } = reader;

    console.log('done', arrayBuffer);
  })
  reader.readAsArrayBuffer(file);
})
```

### Signature 블록 읽어보기
- 바이너리 데이터의 첫 4 바이트 값으로 "8BPS" 문자열을 읽을 수 있다면 정상적인 포토샵 파일인 것으로 간주한다
```JavaScript
const signature = [56, 66, 80, 83];
const value = signature.map((num) => String.fromCharCode(num)).join('');

console.log(value); // "8BPS"
```

### Height 블록 읽어보기
- 배열을 순회할 때 index * 8 만큼 비트 이동 연산을 수행, 누산하여 바이트 단위 숫자 값 획득
```JavaScript
const height = [0, 0, 5, 0];
const value = height
  .map((num, idx, { length }) => num << (length - idx - 1) * 8)
  .reduce((acc, cur) => acc + cur, 0);

console.log(value); // 1280
```

### 레이어 Rectangle 블록 읽어보기
- width, height 값 = 음수일 수 없는 값 = Unsigned Interger
- top, left, right, bottom 값 = 음수도 가능한 값 = Signed Integer
- 블록 설명문을 참고하여 음수일 가능성이 있을 경우 Signed 취급
- "2의 보수"를 취하여 값을 구함

#### DataView 활용하기
- [DataView](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/DataView)는 플랫폼 자체 엔디언(바이트 정렬 방법)에 신경 쓰지 않으면서 ArrayBuffer에서 다양한 숫자 자료형의 데이터를 읽고 쓰기 이ㅜ한 저수준 인터페이스를 제공한다
```JavaScript
const buffer = new ArraryBuffer("10100101"); // 165
const viewer = new DataView(buffer);

// buffer 객체에서 0번째 인덱스부터 데이터를 가져오겠다고 파라미터로 전달
console.log('int', viewer.getInt8(0)); // -91
console.log('uint', viewer.getUint8(0)); // 165
```

### Cursor 객체 만들기
- 비트를 읽어낼 위치값을 개발자가 계속 추적하기 어려우므로, 스스로 위치를 기억하고 인덱스를 갱신하는 객체를 활용
```TypeScript
class Cursor {
  constructor(
    public arr: Array<number>,
    public position: number
  ) { }

  read(type: "i8" | "u8"): number {
    // ...
    position += 1;
  }

  readString(length: number): string {
    // ...
    position += length;
  }
}
```

## 라이브러리 성능 개선

### PSD 파서, 빨라지다
- 기존의 PSD 파서 라이브러리는 느림
- 순수 JavaScript로 재작성하여 성능을 그게 개선 (2x~10x)
- 더 빠르게 할 수 있을까?

### 병목을 찾아라
- PSD 파일의 대부분 이미지 데이터, 디코딩에 많은 시간 소요
- 디코딩 성능을 개선하자!

### 이미지 디코딩
- [Run-Length Encoding](https://en.wikipedia.org/wiki/Run-length_encoding)
   - [Pack Bits](https://en.wikipedia.org/wiki/PackBits)
   - 색이 같은 픽셀이 여러개가 반복될 때 첫번째 바이트에 갯수를, 두번째 바이트에 색상을 저장
- 단순한 알고리즘, 개선에는 한계가 있다
- 데이터를 바이트 단위로 조작하는 저수준의 작업, 높은 성능을 뽑고 싶다
   - `다른 프로그래밍 언어`라면 더 빨랐을 텐데...

### WebAssembly
- 웹 브라우저에서 고성능 작업을 위한 기술
- 기계어에 가까운 저수준의 바이트코드를 실행
- JS보다 빠른 해독과 최적화

### WebAssembly의 특징
- 브라우저가 실행하기에 알맞은 저수준이ㅡ 이진 코드
- 사람이 직접 만들기 어려움
- 다른 언어로 만든 코드를 WebAssembly 바이트코드(.wasm)로 컴파일
- 다양한 하드웨어와 OS에서 실행 가능
- JS와는 독립적인 메모리 공간을 사용한다 => 성능 손실 발생
- 실행하기 위해 JS의 도움이 필요하다 => 개발, 배포 과정이 복잡해짐

### WebAssembly의 동작방식
1. JavaScript에서 WebAssembly로 문자열 "help"를 전달하려 한다
2. "help"를 이진 형식으로 변환한다
3. 변환된 데이터를 WebAssembly의 메모리에 복사한다

### WebAssembly의 실행 방식
1. WASM 파일의 내용을 불러온다
2. `WebAssembly.instantiate(data)`로 모듈 인스턴스 생성
3. WASM 모듈에 들어있는 함수를 호출한다
```JavaScript
fetch('./hello-world.wasm')
  .then(result => result.arrayBuffer())
  .then(data => WebAssembly.instantiate(data))
  .then(({ instance }) => {
    instance.exports.sayHello();
  })
```

### 라이브러리 개발자의 고민
- 다양한 환경에서 우리 라이브러리를 쓰게 하고 싶다
- 실행 환경마다 WASM 파일을 불러오는 방식이 다름
   - 웹: `fetch()`로 다운로드
   - 서버: `fs.readFile()`로 디스크에서 파일을 읽기
- 실행 환경을 탐지해서 적절한 파일 로딩 방식을 쓰자
- 다양한 환경에서 우리 라이브러리를 쓰게 하고 싶다
   - 번들러를 사용한다면?
   - 번들러의 역할
      - 여러 JS파일을 하나의 JS 파일로 통합
      - 빌드할 때 Asset(이미지, CSS, WASM)을 올바른 위치(/assets/)로 복사해준다
   - 번들러마다 WASM 파일을 불러오는 방식이 다르다
   - 특정 번들러와 호환성 이슈 발생

#### Webpack, Parcel의 경우
```JavaScript
import('./hello-world.wasm').then(instance => { instance.sayHello(); });
```

#### Rollup의 경우
```JavaScript
import helloWorld from './hello-world.wasm';

helloWorld().then(instance =>  { instance.sayHello(); });
```

### 해결 방안: JS와 WASM을 합친다
- JS파일 내부에 WASM 파일을 병합하기
   - WASM 파일을 base64 인코딩된 문자열로 저장
   - 모듈 로딩 시 바이너리 데이터로 변환한 다음 WebAssembly 실행
- 장점: 모든 실행 환경과 번들러를 지원함
- 단점: 모듈 로딩이 오래 걸림, 번들이 커짐

### Toolchains
- JS <-> WASM간 데이터 이동을 자동화하는 라이브러리 사용
   - Rust: wasm-bindgen
   - C++: Emscripten Embind
- 번들러 설정을 통해 WebAssembly 모듈을 임베드
   - Vite + vite-plugin-wasm

### Vanilla JS -> Rust + WebAssembly
- Chrome(V8): 디코딩 속도 10%~15% 증가 (시간 10%~15% 감소)
- Firefox (SpiderMonkey): 디코딩 속도 60%~90% 증가 (시간 40%~45% 감소)
- Safari (JavaScriptCore): 디코딩 속도 40%~100% 증가 (시간 30%~50% 감소)

### 브라우저 간 디코딩 성능 비교
- Vanilla JS: 전반적으로 크롬이 성능이 좋은 경향
- WebAssembly: 대부분의 브라우저에서 비슷한 성능

### 교훈: No Silver Bullet
- Chrome (V8)의 JS 최적화는 무시할 수 없다
- 여러 브라우저를 고려한다면 WebAssembly가 유리
- 개발 비용과 난이도가 만만치 않다
