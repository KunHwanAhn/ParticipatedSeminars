# Next.js13으로 알아보는 FE렌더링 방식(SSR vs RSC)
- 윤해수 @ 카카오엔터프라이즈
- [Meetup](https://www.meetup.com/awskrug/events/294944079)

```
- FE렌더링 방식의 변화과정을 짚어보고 Next.js13에서의 RSC가 기존의 SSR과 무엇이 다른지 함께 확인해요.
- 간단한 웹사이트를 함께 만들며 개발방식부터 결과까지 살펴보고 RSC의 장점을 살펴봐요.
- 앞으로의 FE생태계와 FE개발방식이 어떻게 될지 토론해요.
- Next.js를 사용해 본 적이 없어도 좋아요. SSR과 RSC를 전혀 모르시는 분들이라면 더 환영해요!
```

## 렌더링 방식의 변화
- CSR -> SSR
- 최근 렌더링 방식의 변화 과정
- 리액트와 같은 도구의 등장 -> CSR 용어 등장
- Next.js 같은 도구의 등장 -> SSR 용어 등장
- 하지만 SSR은 원래도 있었다.
- 고전적인 웹 페이지 렌더링방식은 MPA
   - 명확하게는 SSR이라고 하기엔 애매함
- 다양한 방식이 존재
   - 원래 완성된 HTML
   - 템플릿 도구 (JSP, PHP, PUG)를 사용하여 HTML
   - 위의 의미에서 SSR이라고도 볼 수 있음
- 전체 페이지를 매번 다시 받거나 그리기에 서버 부하 존재
- 페이지 이동마다 흰 화면 노출
- 리액트와 같은 도구 등장 -> SPA 가능
   - CSR이라는 렌더링 방식 등장
   - 서버로부터 HTML을 받고 JS로 렌더링하는 방식
   - 한번 페이지가 열리면 부드럽게 변환
   - JS파일이 클 경우 로딩 시간 늘어남
   - 초기 HTML로 인해서 SEO 이슈가 발생

> 다시 고전처럼 완성된 HTML이 필요해

- Next.js의 등장 SSR 방식으로 해결
- 완성된 HTML로 SEO 해결
- JS를 받아와서 하이드레이션으로 CSR도 가능
   - 하이드레이션으로 인해서 다른 페이지 이동하더라도 HTML을 새로 고침하지 않음
- React Server Componet
- 요청 위치가 바뀜으로서 강점을 가짐
   - 자주 바뀌는 컴포넌트가 있다면 SSR
   - 기존 SSR은 페이지 단위 이므로 페이지 단위로 전략
   - RSC는 특정 컴포넌트는 캐시를 사용하고, 다른 컴포넌트는 항상 새로 그리는 등의 전략 가능
   - 적절하게 서버의 부하를 조절
   - TTI 개선
   - 번들 사이즈도 작아짐
## Next.js
- 리액트를 위한 오픈소스 JS 웹 프레임워크
- 풀스택 웹 어플리케이션을 만들 수 있음 = 서버 존재
- SSR!
- React 18 개발 당시 RSC라는 개념 등장
- 기술적 이슈로 Next.js에 Server Componet라는 이름으로 추가
- React 공식 문서에서도 최신 리액트 사용하려면 Next.js 사용 권장

## 개발

###  준비사항
- Next.js는 공식 문서는 두 가지 버전
- 13 이전 버전은 Pages 방식
- 서버 컴포넌트를 사용하려면 App Router 방식 이용

#### 프로젝트 셋업
```bash
$ npx craete-next-app@latest # Next v13.4
```
- Pages Router - SSR VS App Router - RSC
- 페이지는 총 3개의 간단한 웹 사이트

##### SSR - Pages Router
- 페이지 기반 라우팅은 파일 기반
   - pages/index.tsx: '/' 페이지를 의미
   - pages/todos/index.tsx: '/todos'를 의미
   - pages/todos/[id].tsx: '/todos/:id'를 의미

##### RSC - App Router
- 앱 라우터 방식은 Next 13에서 도입
- 폴더기반으로 Nested 하게 동작
- 폴더 내의 page.tsx가 페이지 담당
- 폴더 내의 layout.tsx 레이아웃 담당
- 폴더 내의 loading.tsx 로딩 UI 담당
- 폴더 내의 error.tsx가 에러 UI 담당
- TodoList 컴포넌트 내부에 비동기 함수 작성
   - Next13에서는 컴포넌트에서도 Next 내장 fetch 사용 가능
   - 컴포넌트는 기본적으로 서버 컴포넌트이기에 바로 사용 가능
   - 보다 직관적인 모습으로 사용 가능

## 비교

### 비교하기 전에
- 원활한 비교를 위해 스타일링은 module-css로 작성
   - css-in-js로 작성하면 서버컴포넌트에서 js파일을 필요로 함
   - 스타일코드만 받아오는 것이긴 함
   - 그러나 학습 및 비교 차원에서 js 파일을 받아오는지 확인
- APP 라우터에서 fetch쪽 로직 수정
   - 기존에는 디폴트로 작성해서 SSG
   - SSR로 변경하기 위해 `no-store`
   - getServerSideProps와 비교하기 위함

### fetch는 브라우저의 fetch 일까?
- next 서버 컴포넌트의 fetch는 브라우저의 fetch(window.fetch)와는 다름
- fetch와 유사하지만 자체적인 옵션들과 로직이 추가됨

### SSR
- 최초 메인페이지 진입 시 HTML 확인 가능
- next/link로 된 todos 클릭 시 CSR 동작
   - 새로 HTML 다시 받아오지 않음
   - 새로 고침이 없어서 흰페이지가 보이지 않음
- 위 상태에서 새로고침 혹은 주소입력
   - 정상적으로 SSR 동작함을 확임
      - 서버에서 API를 내부적으로 호출하고 HTML을 완성하여 보냄
- 서버컴포넌트도 기존과 동일한 SSR 동작

### 네트워크 요청
- 페이지 기반에서 첫 메인 페이지 진입 후 todos 클릭
   - HTML은 메인페이지
   - 여러 js파일과 json파일 확인 가능
   - 첫 부분은 todos와 관련된 청크 파일
      - 페인페이지 진입시 반아와졌음
      - next/link는 기본적으로 preload 활성화 되어 있음
   - 두번째 json은 링크 클릭시 GET
      - API 요청이 이루어짐
      - 미리 있던 청크파일과 CSR 동작
   - 자세히 보기도 link 프리로드로 동작
- 앱 기반에서 첫 메인페이지 진입 후 todos 클릭
   - 적은양의 js파일과 rsc파일 확인
   - 스타일이나 번들 설정으로 인한 일부 js파일 존재
   - 최초 이후 js파일 받아오지 않음.
      - Link때문에 최초 todos로 시작하는 무언가를 받아옴.
      - 그러나 /todos로 이동했을 때 json이 없음
   자세히 보기를 클릭하더라도 별다른 네트워크 요청 X

### RSC에서는 어떻게 가능할까?
- RSC가 들어간 파일을 살펴보면 동작 추측 가능
   - JSON과 비슷한 형태로 되어 있음
   - 자신의 정보를 위치값으로 추정되는 데이터로 갖고 있음
- Next와 React 코드에 파싱함수 존재
   - next.js/packages/next/src/compiled/react-server-dom-webpack / 컴파일된 공간이 존재
   - react 경로 추가 필요!
- 서버 로그를 확인해보면 프리로드 시 이미 모든 요청 발생
   - 이 정보를 바탕으로 RSC 파일을 보낸 것
   - 결과적으로 서버 컴포넌트는 페이지를 바꾸더라도 JS가 필요 없음
   - API 요청을 완전히 감출 수 있음
   - 캐시 활용성이 매우 높아짐

### 스트리밍
- 필수적인 데이터가 아니라면 제외한채로 페이지를 렌더링할 수 있다
   - SSR이 일어나는 시점에도 일부 컴포넌트에 로딩을 표시할 수 있음
   - 더이상 유저는 완전한 페이지가 서버에서 그려질 때까지 기다리지 않아도 됨
- 기존 SSR은 서버가 아래와 같이 동작
   - 서버에서 필요한 데이터를 받아온다
   - 데이터를 바탕으로 HTML을 그려 보낸다 (TTFB)
   - 클라이언트에서 non-interactive UI가 우선 표시 (FCP)
   - JS를 기반으로 하이드레이션이 일어나 인터렉션이 가능해진다 (TTI)
- UI를 우선 표시한다지만 서버에서 데이터 로드가 끝나야 함.
- 차례대로 위 과정이 일어나며 블로킹 발생 -> 인터랙션 시간이 길어짐
- Next13은 Suspense와 함께 Streaming 지원
   - 직접 Suspense 경계를 만들거나
   - loading 컨벤션을 사용할 수도 있음 (loading.tsx)
- HTML을 더 작은 청크로 분할하여 서버에서 점진적으로 전송하는 방식
   - 이를 통해 페이지 일부를 더 빨리 전송 -> TTFB 개선
   - 우선순위가 높거나 데이터에 의존하지 않는 컴포넌트 먼저 표시 -> FCP 개선
   - 리액트는 하이드레이션을 더 일찍 시작할 수 있음 -> TTI 개선
- todos/loading.tsx를 작성해 넣는다면 SSR 동작 확인 가능
   - 초기 HTML에는 리스트 컴포넌트를 제외하고 로딩 컴포넌트로 보냄
   - 서버에서 데이터 호출이 완료된 이후 컴포넌트가 완전히 그려짐

### 요청 위치
- 페이지 기반 라우팅에서는 SSR 함수를 page 컴포넌트에 작성
- 앱 기반 라우팅에서는 컴포넌트에 서버 로직 작성 가능
- 서버 컴포넌트로 인해 3가지 장점을 가짐
   - 관심사의 분리: 페이지는 완전히 view 역할만
   - props 드릴링 해결: 기존에는 비동기 로직을 페이지에 작성후 컴포넌트에 내려줘야 했음
   - 다양한 SSR 전략: 컴포넌트 단위로 SSR 전략을 가져갈 수 있음

### 번들 사이즈
- 앱 기반이 Size가 좀 더 작은 것을 알 수 있음
   - 서버 컴포넌트 이기 때문 -> 서버에서만 렌더링
   - 클라이언트 번들링에 포함되지 않음
- 전반적인 JS 파일도 줄어들게 됨
   - TTI에서 스ㅡ리밍과 더불어 강점
   - 기존 SSR은 JS에 모든 내용을 담아야 함 = LCP, FCP만 CSR보다 빠름
   - 스트리밍으로 인해 TTI 감소, JS파일 감소로 인한 개선 효과를 모드 가져갈 수 있음

### 서버
- 극단적인 SSR이 가능해짐
   - 인터랙션이 최소화될 수록 JS파일을 받지 않음
- SSR 강점 극대화
   - API 요청을 모두 숨길 수 있어 보안성 증가
   - 컴포넌트 단위의 캐시 -> 100만명 요청이 있어도 최초 요청만 캐시
- 캐시 전략의 다양화
   - 페이지가 아닌 컴포넌트 단위
   - 특정 컴포넌트만 자주 요청

### 클라이언트
- 네트워크 요청이 매우 가벼워짐

### 개발
- 유지보수에 유리한 코드 작성
   - 페이지에 작성했어야 했던 비즈니스 로직을 컴포넌트로 위임
- 관심사의 분리 효과 증대
   - 클라이언트 컴포넌트와 서버컴포넌트 분리하여 작성    - 자연스럽게 관심사의 분리
- 복잡해진 컴포넌트 트리 구조
   - 리액트 훅이나 브라우저 API를 사용하려면 반드시 클라이언트 컴포넌트로 만들어야 함
   - 클라이언트 컴포넌트 하위의 서버컴포넌트는 제약이 존재
   - 최하단에 클라이언트 컴포넌트를 넣기를 권장
- 적절한 컨벤션의 부재
   - Best Practics가 아직 없음
   - 발전 가능성 본재
      - SWR, react-query, RTKQuery
- 잘 정립되면, 획기적인 발전이 될수도?

## Q & A
- 클라이언트 컴포넌트 하위의 서버컴포넌트 제약이 뭘까?
   - 서버 컴포넌트를 import하면 오류가 발생하며 의도대로 동작하지 않음
   - import를 하지 않고 children으로 사용해야 함
- 데이터 fetch 관련해서 서버 컴포넌트에서만 fetch하는 것이 쉽지 않음
   - SSR을 할 때에는...?!?!
- fetch를 사용해서 비동기 통신을 한다고 했는데, axios 같은 도구를 사용해서 서버 컴포넌트에 적용이 가능한지?
   - 해본적은 없으나, 개인 입장에서는 될 것이라 생각함.
   - 서버 컴포넌트에서는 Next.js에서 제공하는 전략을 사용하려면 next/fetch를 사용해야 할 것 같음
- 서버 컴포넌트는 병렬로 처리되는 건가? layout -> repaint 같은 과정을 거칠텐데 성능 상으로 이슈가 있을지?
   - 확인해보지 않아서 잘은 모르겠음
- JS를 안 쓰는게 왜 중요한가?
   - JS를 안 씀으로 얻는 이점은 번들링 사이즈가 줄어서 사용자가 첫 접속을 했을 때 빠르게 볼 수 있다
   - JS가 없어서 페이지를 이동하더라도 새로 가져오지 않는다
   - react-hook이나 client 컴포넌트를 사용해야 하기에 현실적으로 JS가 없을 수가 없다
- Next.js 12 -> 13으로 바꾸는 과정
   - 처음에는 pages 라우트를 사용할 것 같다
   - 가능한 컴포넌트부터 순차적으로 올리면서 확인해보면 될듯?
- CSS-in-JS 라이브러리들이 잘 동작하지 않는 것 같은데..
   - styled-component로 해봤을 때 잘 안됐다
   - CSS-in-JS를 쓰다보니 클라이언트 컴포넌트가 될 수 밖에 없을 것 같다
   - 서버에서는 HTML을 써서 만드는 무언가를 구현해야 하지 않을까, 앞으로 그렇게 지원하지 않을까?
- 클라이언트 컴포넌트는 서버에서 렌더링이 전혀 안되는 걸까?
   - 그렇지 않음
   - 실제로 안되게 하려면 next/dynamic의 ssr:false와 같은 옵션을 줘야 함
   - 실제로 어떤식으로 렌더링 되는지 보려면 브라우저에서 개발자도구를 열어서 JS disable 활성화
   - 인터랙티브한 엘리먼트가 동작하지 않을 뿐
- Next.js로 개발할 때 Dev 모드로 개발할 때, 많이 느린 것 같은데
   - Dev 서버를 띄울 때 turbopack을 쓰는 방법이 있는데, 그걸 쓰면 속도 개선이 있을 듯
- RSC를 쓰면 서버의 비용이 더 나올 가능성이 있을까?
   - 기존의 pages 라우터보다 적게 나올 것으로 예상
   - 페이지에서 자주 바뀌는 컴포넌트가 있다면 SSR을 썼어야 했다.
   - RSC에서 자주 바뀌지 않는 데이터는 재사용할 것이고, 바뀌는 데이터만 사용할 것이기에 적게 사용할 것 같다
